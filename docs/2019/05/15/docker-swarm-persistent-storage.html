<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> <title>Docker Swarm Persistent Storage | TheWorkAround</title> <meta name="generator" content="Jekyll v3.8.5"/> <meta property="og:title" content="Docker Swarm Persistent Storage"/> <meta name="author" content="Brandon Hicks"/> <meta property="og:locale" content="en_US"/> <meta name="description" content="Docker-swarm persistent storage using glusterFS (a network filesystem)"/> <meta property="og:description" content="Docker-swarm persistent storage using glusterFS (a network filesystem)"/> <link rel="canonical" href="http://theworkaround.com/2019/05/15/docker-swarm-persistent-storage.html"/> <meta property="og:url" content="http://theworkaround.com/2019/05/15/docker-swarm-persistent-storage.html"/> <meta property="og:site_name" content="TheWorkAround"/> <meta property="og:type" content="article"/> <meta property="article:published_time" content="2019-05-15T00:00:00-06:00"/> <script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"http://theworkaround.com/2019/05/15/docker-swarm-persistent-storage.html"},"url":"http://theworkaround.com/2019/05/15/docker-swarm-persistent-storage.html","headline":"Docker Swarm Persistent Storage","dateModified":"2019-05-15T00:00:00-06:00","datePublished":"2019-05-15T00:00:00-06:00","description":"Docker-swarm persistent storage using glusterFS (a network filesystem)","author":{"@type":"Person","name":"Brandon Hicks"},"@type":"BlogPosting","@context":"https://schema.org"}</script> <meta name="title" content="Docker Swarm Persistent Storage | TheWorkAround"> <meta name="keywords" content="docker,docker-swarm,gluster,linux"> <meta name="google" content="notranslate"> <meta name="robots" content="index, follow"> <meta http-equiv="Content-Language" content="en"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <link rel="preconnect" href="https://fonts.googleapis.com/" crossorigin> <link rel="preconnect" href="https://www.google-analytics.com/" crossorigin> <link rel="preconnect" href="https://ajax.googleapis.com/" crossorigin> <link rel="preconnect" href="https://cdnjs.cloudflare.com/" crossorigin> <link rel="dns-prefetch" href="https://fonts.googleapis.com/"> <link rel="dns-prefetch" href="https://www.google-analytics.com/"> <link rel="dns-prefetch" href="https://ajax.googleapis.com/"> <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com/"> <meta name="theme-color" content="#4cb8c4"> <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css" integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous"> <link rel="stylesheet" href="/assets/stylesheets/app-a09f5d095871465ede6b58bcd69c865d37a9decae5f0de1f17b636e1913e8966.css" integrity="sha256-oJ9dCVhxRl7ea1i81pyGXTep3srl8N4fF7Y24ZE+iWY=" crossorigin="anonymous"> <!--[if lt IE 9]><script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script> <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script><![endif]--> <!--[if lte IE 8]><script src="https://cdnjs.cloudflare.com/ajax/libs/ie8/0.8.0/ie8.js"></script><![endif]--> <link href="/atom.xml" rel="alternate" title="Atom" type="application/atom+xml"> <link href="/rss.xml" rel="alternate" title="RSS" type="application/rss+xml"> <link href="/sitemap.xml" rel="sitemap" title="Sitemap" type="application/xml"> <link href="/humans.txt" rel="author" type="text/plain"> </head> <body> <div class="container-fluid"> <div class="site"> <div class="row"> <div class="col-md-2"> <div class="social-icons d-flex justify-content-around justify-content-md-end"> <a href="/" title="Return to Homepage" class="mx-2">/</a> <a href="http://twitter.com/tarellel" title="Follow me on Twitter" class="mx-2" rel="me"> <em class="fab fa-twitter"></em> </a> <a href="http://github.com/tarellel" title="View my code on GitHub" class="mx-2" rel="me"> <em class="fab fa-github"></em> </a> <a href="mailto:&#116;&#097;&#114;&#101;&#108;&#108;&#101;&#108;&#064;&#103;&#109;&#097;&#105;&#108;&#046;&#099;&#111;&#109;" title="Email Me" class="mx-2" rel="email"> <em class="fa fa-envelope"></em> </a> </div> <div class="text-right navlinks d-flex justify-content-around flex-md-column p-0 my-2"> <a href="/about" class="nav-items my-sm-3 my-md-0">About</a> <a href="/archive" class="nav-items my-sm-3 my-md-0">Archive</a> </div> </div> <div class="col-md-10 px-3"> <h1 class="post-title">Docker Swarm Persistent Storage</h1> <div class="row"> <div class="d-flex align-self-center w-100 px-3 py-0 mb-xs-3"> <p class="meta w-50 my-1">May 15, 2019</p> <div class="w-50 text-right"> Tags: <a href="/tag/docker/" rel="tag">docker</a>, <a href="/tag/docker-swarm/" rel="tag">docker-swarm</a>, <a href="/tag/gluster/" rel="tag">gluster</a>, <a href="/tag/linux/" rel="tag">linux</a> </div> </div> </div> <div class="post"> <p>Unless you’ve been living under a rock, you should need no explanation what <a href="https://www.docker.com/">Docker</a> is. Using Docker over the last year has drastically improved my deployment ease and with coupled with <a href="https://about.gitlab.com/">GitLab’s</a> CI/CD has made deployment extremely ease. Mind you, not all our applications being deployed have the same requirements, some are extremely simple and others are extraordinarily complex. So when we start a new project we have a base docker build to begin from and based on the applications requirements we add/remove as needed.</p> <h3 id="a-little-about-docker-swarm">A little about Docker Swarm</h3> <p>For the large majority of most of our applications, having a volume associated with the deployed containers and storing information is the database fits the applications needs.</p> <p>In front of all our applications we used to use <a href="https://proxy.dockerflow.com/">Docker Flow Proxy</a> to quickly integrate our application into our deployed environment and assign it a subdomain based on it’s service. For a few months we experienced issues with the proxy hanging up, resources not being cleared, and lots of dropped connections. Since than I have rebuilt our docker infrastructure and now we use <a href="https://traefik.io/">Traefik</a> for our proxy routing and it has been absolutely amazing! It’s extremely fast, very robust and extensible, and easy to manipulate to fit your needs. Heck before even deploying it I was using <a href="https://docs.docker.com/compose/">docker-compose</a> to build a local network proxy to ensure it was what we needed. While Traefik was running in compose I was hitting domains such as <code class="highlighter-rouge">http://whoami.localhost/</code> and this was a great way to learn the basic configuration before pushing it into a staging/production swarm environment. <em>(That explaing how we got started with Traefik is a whole other post of it’s own.)</em></p> <p>Now back to our docker swarm, I know the big thing right now is <a href="https://kubernetes.io/">Kubernetes</a>. But every organization has their specific needs, for their different environments, application, types, and deployment mechanisms. In my opinion the current docker environment we’ve got running right now is pretty robust. We’ve got dozens of nodes, a number of deployment environments (cybersec, staging, and production), dozens of applications running at once, and some of then requiring a number of services in order to function properly.</p> <p>A few of the things that won me over on the docker swarm in the first place is it’s load balancing capabilities, it’s very fault-tolerant, and the self-healing mechanism that it uses in case a container crashes, a node locks up or drops, or a number of other issues. <em>(We’ve had a number of servers go down due to networking issues or a rack server crapping out and with the docker swarm running you could never even tel we were having issues as an end user to our applications.)</em></p> <p><em class="small">(Below is an image showing traffic hitting the swarm. If you have an application replicated upon deployment, traffic will be distributed amongst the nodes to prevent bottle necks.)</em></p> <p><img src="/img/posts/docker-swarm-persistent-storage/SwarmTraffic.svg" alt="Docker Swarm Traffic" class="img-fluid"/></p> <h3 id="why-would-you-need-persistent-storage">Why would you need persistent storage?</h3> <p>Since the majority of our applications are data orientated, (with most of them hitting several databases in a single request) we hadn’t really had to worry about persistent storage. This is because once we deployed the applications; their volumes held all of their required assets and any data they needed was fetched from the database.</p> <p>The easiest way to explain volumes, is when a container is deployed to a node (if specified) it will put aside a section of storage specifically for that container. For example say we have an application called DogTracker the was deployed on node A and B. This application can create and store files in their volumes on those nodes. But what happens when there’s an issue with the container on node A and the container cycles to node C? The data created by the container is left in the volume on node A an no longer available, until that applications container cycles back to node A.</p> <p>And from this arises the problem we began to face. We were starting to develop applications that were starting to require files to be shared amongst each other. We also have numerous applications that require files to be saved and distributed without them being dumped into the database as a blob. And these files were required to be available without cycling volumes and/or dumping them into the containers during build time. And because of this, we needed to be able to have some form of persistent and distributed file storage across our containers.</p> <p><em class="small">(Below is an image showing how a docker swarms volumes are oriented)</em></p> <p><img src="/img/posts/docker-swarm-persistent-storage/DockerSwarm.svg" alt="Docker Swarm Diagram" class="img-fluid"/></p> <h3 id="how-we-got-around-this">How we got around this!</h3> <p>Now in this day an age there’s got to be ways to get around this. There’s at least 101 ways to do just about anything and it doesn’t always have to be newest shiniest toy everyone’s using. I know saying this while using Docker is kind of a hypocritical statement, but shared file systems have been around for decades. You’ve been able to mount network drives, ftp drives, have organizational based shared folders, the list can go on for days.</p> <p>But the big question is, how do we get a container to mount a local shared folder or distribute volumes across all swarm nodes? Well, there’s a whole list of distributed filesystems and modern storage mechanisms in the <a href="https://docs.docker.com/engine/extend/legacy_plugins/">docker documentation</a>. Below is a list of the top recommended alternatives I found for <a href="https://en.wikipedia.org/wiki/Distributed_File_System_(Microsoft)">distributed file systems</a> or <a href="https://en.wikipedia.org/wiki/Network_File_System">NFS’s</a> for the docker stratosphere around container development.</p> <ul> <li><a href="https://ceph.com/">Ceph</a></li> <li><a href="https://github.com/rancher/convoy">Convoy</a></li> <li><a href="https://github.com/rexray/rexray">RexRay</a></li> <li><a href="https://portworx.com/use-case/docker-persistent-storage/">PortWorx</a></li> <li><a href="https://github.com/pvdbleek/storageos">StorageOS</a></li> <li><a href="http://www.xtreemfs.org/">xtreemfs</a></li> </ul> <p>I know you’re wondering why we didn’t use <a href="https://aws.amazon.com/s3/">S3</a>, <a href="https://www.digitalocean.com/products/spaces/">DigitalOcean Spaces</a>, <a href="https://cloud.google.com/storage/docs/">GCS</a>, or some other cloud storage. But internally we have a finite amount of resources and we can spin up VM’s and be rolling in a matter of moments. Especially considering we have build a number of <a href="https://www.ansible.com/">Ansible</a> playbooks to quickly provision our servers. Plus, why throw resources out on the cloud, when it’s not needed. Especially when we can metaphorically create our own network based file system and have our own cloud based storage system.</p> <p><em class="small">(Below is an image showing we want to distribute file system changes)</em></p> <p><img src="/img/posts/docker-swarm-persistent-storage/DockerSwarm_wStorage.svg" alt="" class="img-fluid"/></p> <p>After looking at several methods I settled on <a href="https://www.gluster.org/">GlusterFS</a> a scalable network filesystem. Don’t get me wrong, a number of the other alternatives are pretty ground breaking and some amazing work as been put into developing them. But I don’t have thousands of dollars to drop on setting up a network file system, that may or may not work for our needs. There were also several others that I did look pretty heavily into, such as <a href="https://github.com/pvdbleek/storageos">StorageOS</a> and <a href="https://ceph.com/">Ceph</a>. With StorageOS I really liked the idea of a container based file system that stores, synchronizing, and distributes files to all other storage nodes within the swarm. And it may just be me, but Ceph looked like the prime competitor to Gluster. They both have their <a href="https://technologyadvice.com/blog/information-technology/ceph-vs-gluster/">high points</a> and seem to work very reliable. But at the time; it wasn’t for me and after using Gluster for a few months, I believe that I made the right choice and it’s served it’s purpose well.</p> <p><a href="https://www.gluster.org/"><img src="/img/posts/docker-swarm-persistent-storage/gluster-ant.png" alt="Gluster Ant" class="img-fluid w-25"/></a></p> <h4 id="gluster-notes">Gluster Notes</h4> <p><em>(<strong>Note:</strong> The following steps are to be used on a Debian/Ubuntu based install.)</em></p> <p>Documentation for using Gluster can be found on their <a href="https://docs.gluster.org/en/latest/">docs</a>. Their installation instructions are very brief and explain how to install the gluster packages, but they don’t go into depth in how to setup a Gluster network. I also suggest thoroughly reading through to documentation to understand Gluster volumes, bricks, pools, etc.</p> <h3 id="installing-glusterfs">Installing GlusterFS</h3> <p>To begin you will need to list all of the Docker Swarm nodes you wish to connect in the <code class="highlighter-rouge">/etc/hosts</code> files of each server. On linux (Debian/Ubuntu), you can get the current nodes IP Address run the following command <code class="highlighter-rouge">hostname -I | awk '{print $1}'</code></p> <p><em class="fa fa-info-circle"> </em> <em class="small">(The majority of the commands listed below need to be ran on each and every node simultaneously unless specified. To do this I opened a number of terminal tabs and connected to each server in a different tab.)</em></p> <div class="language-config highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># /etc/hosts
</span><span class="m">10</span>.<span class="m">10</span>.<span class="m">10</span>.<span class="m">1</span> <span class="n">staging1</span>.<span class="n">example</span>.<span class="n">com</span> <span class="n">staging1</span>
<span class="m">10</span>.<span class="m">10</span>.<span class="m">10</span>.<span class="m">2</span> <span class="n">staging2</span>.<span class="n">example</span>.<span class="n">com</span> <span class="n">staging2</span>
<span class="m">10</span>.<span class="m">10</span>.<span class="m">10</span>.<span class="m">3</span> <span class="n">staging3</span>.<span class="n">example</span>.<span class="n">com</span> <span class="n">staging3</span>
<span class="m">10</span>.<span class="m">10</span>.<span class="m">10</span>.<span class="m">4</span> <span class="n">staging4</span>.<span class="n">example</span>.<span class="n">com</span> <span class="n">staging4</span>
<span class="m">10</span>.<span class="m">10</span>.<span class="m">10</span>.<span class="m">5</span> <span class="n">staging5</span>.<span class="n">example</span>.<span class="n">com</span> <span class="n">staging5</span>
</code></pre></div></div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Update &amp; Upgrade all installed packages</span>
apt-get update <span class="o">&amp;&amp;</span> apt-get upgrade <span class="nt">-y</span>

<span class="c"># Install gluster dependencies</span>
<span class="nb">sudo </span>apt-get <span class="nb">install </span>python-software-properties <span class="nt">-y</span>
</code></pre></div></div> <p>Add the GlusterFS <a href="https://itsfoss.com/ppa-guide/">PPA</a> package the list of trusted packages to install from a community repository.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>add-apt-repository ppa:gluster/glusterfs-3.10<span class="p">;</span>
<span class="nb">sudo </span>apt-get update <span class="nt">-y</span> <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>apt-get update
</code></pre></div></div> <p>Now lets install gluster</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> glusterfs-server attr
</code></pre></div></div> <p>Now before starting the Gluster service but I had to copy some files into systemd <em>(you may or may not have to do this)</em>. But since Gluster was developed by <a href="https://www.redhat.com/en/technologies/storage/gluster">RedHat</a> primarily for <a href="https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux">RedHat</a> and <a href="https://www.centos.org/">CentOS</a>, I had a few issues starting the system service.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo cp</span> /etc/init.d/glusterfs-server /etc/systemd/system/
</code></pre></div></div> <p>Let’s start and enable the glusterfs system service</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl <span class="nb">enable </span>glusterfs-server<span class="p">;</span> systemctl start glusterfs-server
</code></pre></div></div> <p>This step isn’t necessary, but I like to verify that</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Verify the gluster service is enabled</span>
systemctl is-enabled glusterfs-server
<span class="c"># Check the system service status of the gluster-server</span>
systemctl status glusterfs-server
</code></pre></div></div> <p>If for some reason you haven’t done this yet, each and every node should have it’s own ssh key generated.</p> <p><em class="small">(The only reason I can think of why they wouldn’t have a different key is if a VM was provisioned and than cloned for similar use across a swarm.)</em></p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># This is to generate a very basic SSH key, you may want to specify a key type such as ED25519 or bit length if required.</span>
ssh-keygen <span class="nt">-t</span> rsa
</code></pre></div></div> <p>Dependant on your Docker Swarm environment and which server you’re running as a manager; you’ll probably want one of the node managers to also be a gluster node manager as well. I’m going to say server <code class="highlighter-rouge">staging1</code> is one of our node managers, so on this server we’re going to probe all other gluster nodes to add them to the gluster pool. (Probing them essentially is saying this manager is telling all servers on this list to connect to each-other.)</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gluster peer probe staging1<span class="p">;</span> gluster peer probe staging2<span class="p">;</span> gluster peer probe staging3<span class="p">;</span> gluster peer probe staging4<span class="p">;</span> gluster peer probe staging5<span class="p">;</span>
</code></pre></div></div> <p>It’s not required, but probably good practice to ensure all of the nodes have connected to the pool before setting up the file system.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gluster pool list

<span class="c"># =&gt; You should get results similar to the following</span>
UUID					Hostname 	State
a8136a2b-a2e3-437d-a003-b7516df9520e	staging3 	Connected
2a2f93f6-782c-11e9-8f9e-2a86e4085a59	staging2 	Connected
79cb7ec0-f337-4798-bde9-dbf148f0da3b	staging4 	Connected
3cfc23e6-782c-11e9-8f9e-2a86e4085a59	staging5 	Connected
571bed3f-e4df-4386-bd46-3df6e3e8479f	localhost	Connected

<span class="c"># You can also run the following command to another set of results</span>
gluster peer status
</code></pre></div></div> <p>Now lets create the gluster data storage directories <em>(<strong>It’s very important you do this on every node.</strong> This is because this directory is where all gluster nodes will store the distributed files locally.)</em></p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /gluster/brick
</code></pre></div></div> <p>Now lets create a gluster volume across all nodes (again run this on the master node/node manager).</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>gluster volume create staging-gfs replica 5 staging1:/gluster/brick staging2:/gluster/brick staging3:/gluster/brick staging4:/gluster/brick staging5:/gluster/brick force
</code></pre></div></div> <p>The next step is to initialize the glusterFS to begin synchronizing across all nodes.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gluster volume start staging-gfs
</code></pre></div></div> <p>This step is also not required, but I prefer to verify the gluster volume replicated across all of the designated nodes.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gluster volume info
</code></pre></div></div> <p>No let’s ensure we have gluster mount the <code class="highlighter-rouge">/mtn</code> directory for it’s shared directory especially on a reboot. <strong><em>(It’s important to run these commands on all gluster nodes.)</em></strong></p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>umount /mnt
<span class="nb">sudo echo</span> <span class="s1">'localhost:/staging-gfs /mnt glusterfs defaults,_netdev,backupvolfile-server=localhost 0 0'</span> <span class="o">&gt;&gt;</span> /etc/fstab
<span class="nb">sudo </span>mount.glusterfs localhost:/staging-gfs /mnt
<span class="nb">sudo chown</span> <span class="nt">-R</span> root:docker /mnt
</code></pre></div></div> <p><em class="small">(You may have noticed the setting of file permissions using <code class="highlighter-rouge">chown -R root:docker</code> this is to ensure docker will have read/write access to the files in the specified directory.)</em></p> <p>If for some reason you’ve already deployed your staging gluster-fs and need to remount the staging-gfs volume you can run the following command. Otherwise you should be able to skip this step.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>umount /mnt<span class="p">;</span> <span class="nb">sudo </span>mount.glusterfs localhost:/staging-gfs /mnt<span class="p">;</span> <span class="nb">sudo chown</span> <span class="nt">-R</span> root:docker /mnt
</code></pre></div></div> <p>Let’s list all of our mounted partitions and ensure that the <code class="highlighter-rouge">staging-gfs</code> is listed.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">df</span> <span class="nt">-h</span>

<span class="c"># =&gt; staging-gfs should be listed in the partitions/disks listed</span>
localhost:/staging-gfs              63G   13G   48G  21% /mnt
</code></pre></div></div> <p>Now that all of the work is pretty much done, now comes the fun part lets test to make sure it all works. Lets <code class="highlighter-rouge">cd</code> into the <code class="highlighter-rouge">/mnt</code> directory and create a few files to make sure they will sync across all nodes. <em>(I know this is one of the first things I wanted to try out.)</em> You can do one of the following commands to generate a random file in the <code class="highlighter-rouge">/mnt</code> directory. Now depending on your servers and network connections this should sync up across all nodes almost instantly. The way I tested this I was in the <code class="highlighter-rouge">/mtn</code> directory on several nodes in several terminals. And as soon as I issued the command I was running the <code class="highlighter-rouge">ls</code> command in the other tabs. And depending on the file size, it may not sync across all nodes instantly, but is at least accessible.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># This creates a 24MB file full of zeros</span>
<span class="nb">dd </span><span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>output.dat <span class="nv">bs</span><span class="o">=</span>24M  <span class="nv">count</span><span class="o">=</span>1

<span class="c"># Creates a 2MB file of random characters</span>
<span class="nb">dd </span><span class="k">if</span><span class="o">=</span>/dev/urandom <span class="nv">of</span><span class="o">=</span>output.log <span class="nv">bs</span><span class="o">=</span>1M <span class="nv">count</span><span class="o">=</span>2
</code></pre></div></div> <h3 id="using-glusterfs-with-docker">Using GlusterFS with Docker</h3> <p>Now that all the fun stuff is done if you have looked at docker <a href="https://docs.docker.com/storage/volumes/">volumes</a> or <a href="https://docs.docker.com/storage/bind-mounts/">bind</a> mounts this would probably be a good time. Usually docker will store a volumes contents in a folder structure similar to the following: <code class="highlighter-rouge">/var/lib/docker/volumes/DogTracker/_data</code>.</p> <p>But in your <code class="highlighter-rouge">docker-compose.yml</code> or <code class="highlighter-rouge">docker-stack.yml</code> you can specify specific mount points for the docker volumes. If you look at the following <a href="https://en.wikipedia.org/wiki/YAML">YAML</a> snippet you will notice I’m saying to store the containers <code class="highlighter-rouge">/opt/couchdb/data</code> directory on the local mount point <code class="highlighter-rouge">/mnt/staging_couch_db</code>.</p> <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.7'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">couchdb</span><span class="pi">:</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">couchdb:2.3.0</span>
  <span class="na">volumes</span><span class="pi">:</span>
   <span class="pi">-</span> <span class="na">type</span><span class="pi">:</span> <span class="s">bind</span>
     <span class="na">source</span><span class="pi">:</span> <span class="s">/mnt/staging_couch_db</span>
     <span class="na">target</span><span class="pi">:</span> <span class="s">/opt/couchdb/data</span>
  <span class="na">networks</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">internal</span>
  <span class="na">deploy</span><span class="pi">:</span>
    <span class="na">resources</span><span class="pi">:</span>
      <span class="na">limits</span><span class="pi">:</span>
        <span class="na">cpus</span><span class="pi">:</span> <span class="s1">'</span><span class="s">0.30'</span>
        <span class="na">memory</span><span class="pi">:</span> <span class="s">512M</span>
      <span class="na">reservations</span><span class="pi">:</span>
        <span class="na">cpus</span><span class="pi">:</span> <span class="s1">'</span><span class="s">0.15'</span>
        <span class="na">memory</span><span class="pi">:</span> <span class="s">256M</span>
</code></pre></div></div> <p>Now as we had previously demonstrated any file(s) saved, created, and/or deleted in the <code class="highlighter-rouge">/mtn</code> directory will be synchronized across all of the GlusterFS nodes.</p> <p>I’d just like to mention this may not work for everyone, but this is the method that worked best for use. We’ve been running a number of different Gluster networks for several months now with no issues <em>thus far</em>.</p> </div> <div class="ads"> <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-0584655001678892",enable_page_level_ads:!0});</script> </div> <div id="disqus_thread"></div> <script>!function(){var e=document,t=e.createElement("script");t.src="//theworkaround.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)}();</script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript> </div> </div> </div> </div> <script>!function(e,a,n,t,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(n),s=a.getElementsByTagName(n)[0],o.async=1,o.src=t,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-41384218-1","theworkaround.com"),ga("send","pageview");</script> </body> </html>