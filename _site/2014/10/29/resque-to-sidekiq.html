<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Resque to Sidekiq - The Work Around</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,600' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/assets/app-8ec3912918a69c1273b6888617901a4c.css">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if IE 7]>
      <script src="/assets/css/font-awesome-ie7.css"></script>
    <![endif]-->

    <link href="/atom.xml" rel="alternate" title="Atom" type="application/atom+xml">
    <link href="/rss.xml" rel="alternate" title="RSS" type="application/rss+xml">
    <link href="/sitemap.xml" rel="sitemap" title="Sitemap" type="application/xml">
    <link href="/humans.txt" rel="author" type="text/plain">

    <!-- Prefectch to Optimize Site Loading - src: http://csswizardry.com/ -->
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="dns-prefetch" href="//www.google-analytics.com">
    <link rel="dns-prefetch" href="//ajax.googleapis.com">

    <meta name='title' content='Resque to Sidekiq - The Work Around'>
    <meta name='og:title' content='Resque to Sidekiq - The Work Around'>
    <meta property='og:url' content='http://theworkaround.com/2014/10/29/resque-to-sidekiq.html'>

    <meta content="article" property="og:type">
    <meta name="author" content="Brandon Hicks">
    <meta name="keywords" content="ruby, rails, redis">


<meta name="description" content="">



  <meta name="keywords" content="ruby,rails,redis">

</head>
<body>
  <div class="container">
    <div class="site">
      <div class="row">
        <div class="span2 text-right">
          <div class="social-icons">
          <p>
            <a href="/" title="Return to Homepage">/</a>
            <a href="http://twitter.com/tarellel" title="Follow me on Twitter" rel="me">
              <i class="icon-twitter"></i>
            </a>
            <a href="http://github.com/tarellel" title="View my code on GitHub" rel="me">
              <i class="icon-github"></i>
            </a>
            <a href="mailto:&#116;&#097;&#114;&#101;&#108;&#108;&#101;&#108;&#064;&#103;&#109;&#097;&#105;&#108;&#046;&#099;&#111;&#109;" title="Email Me" class="email">
              <i class="icon-envelope-alt"></i>
            </a>
          </p>
          </div>
          <div class="text-right navlinks">
            <a href="/about">About</a><br/>
            <a href="/archive">Archive</a>
          </div>
        </div>
        <div class="span9 content">
          <h2 class="post-title">Resque to Sidekiq</h2>
<div class="row">
  <div class="span2">
    <p class="meta">October 29, 2014</p>
  </div>
  <div class="span7 text-right">
    
      Tags: <a href="/tag/ruby.html" rel="tag">ruby</a>, <a href="/tag/rails.html" rel="tag">rails</a>, <a href="/tag/redis.html" rel="tag">redis</a>
    
  </div>
</div>
<div class="post">
<p>Background processing is an important feature with any web application to improve performance.
Not only does it free up your application for requests, it can be used to prioritize tasks and delay processes until your system has available resources.</p>

<p>This post is not about <a href="https://github.com/collectiveidea/delayed_job">delayed_job</a>, <a href="https://kr.github.io/beanstalkd/">beanstalkd</a>, <a href="https://github.com/mperham/girl_friday">girl_friday</a>, <a href="https://github.com/brandonhilkert/sucker_punch">sucker_punch</a>, or a <a href="https://www.ruby-toolbox.com/categories/Background_Jobs">wide selection</a> of other background processors.
Even though I’ve used delayed_job which is amazingly easy to setup and use, I don’t exactly want to clog up my ActiveRecord database with database queries. The use of a key-value store tends to make things fast and simple as it is.
For background jobs, caching, and various other tasks Redis does an amazing job: it’s fast, reliable, and does over complicate the application.</p>

<p>Until recently I had been using <a href="https://github.com/resque/resque">Resque</a> the Holy Grail of Ruby based background processors and it has worked flawlessly to the needs I required.
But one of the applications I have setup allows users to upload as many images (using <a href="https://github.com/carrierwaveuploader/carrierwave">Carrierwave</a>) as they want at any given time.
Upon successful upload of these images the files mime-types and extensions are verified to ensure that malicous files aren’t being uploaded to the server.
Than the images are processed to create thumbnails, gallery images, etc. and when you’re processing numerous image files at one time without background processing this absolutely bogs down a server.
When you have some a mechanism to do this effecively in the background this doesn’t have such a huge impact. But as of lately with a higher user base the image uploads have begin to display delayes in their processing times.</p>

<p>It may not seem like much, but when it’s a few images here and there from numerous users at any given time, the processing time begins to add up.
Especially when upon upload a thumbnail is generated and expected to be displayed almost immediately showing the available uploads for use.</p>

<p>One great thing about Sidekiq is that just like Resque it uses <a href="http://redis.io/">Redis</a>, if you’ve never used Redis before, please do us all a favor and at least give a quick try.
Compared to large SQL databases it’s very simple (key/value pair) and extremely fast, <a href="https://github.com/redis-store/redis-rails">some people</a> have gone as far to use it for caching, sessions, and various other tasks.</p>

<p>The amazing part that makes this migration from Resque to Sidekiq fast and easy is that both libraries use Redis as their backend database to keep track of queues/tasks.
A lot of the gems and initializers just require that you to change the backend from resque to sidekiq, while others just adjust to detecting what’s available.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># carrierwave_backgrounder</span>
<span class="n">c</span><span class="o">.</span><span class="n">backend</span> <span class="ss">:resque</span>
<span class="n">c</span><span class="o">.</span><span class="n">backend</span> <span class="ss">:sidekiq</span>

<span class="c1"># devise-async</span>
<span class="no">Devise</span><span class="o">::</span><span class="no">Async</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="ss">:resque</span>
<span class="no">Devise</span><span class="o">::</span><span class="no">Async</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="ss">:sidekiq</span></code></pre></div>

<p>In order to get everything working propely with your gems only slight adjustments are required.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># Gemfile</span>

<span class="c1">#gem &#39;resque&#39;, :require =&gt; &quot;resque/server&quot;</span>
<span class="n">gem</span> <span class="s1">&#39;sidekiq&#39;</span><span class="p">,</span> <span class="ss">:github</span> <span class="o">=&gt;</span> <span class="s1">&#39;mperham/sidekiq&#39;</span>
<span class="n">gem</span> <span class="s1">&#39;devise-async&#39;</span>
<span class="n">gem</span> <span class="s1">&#39;carrierwave_backgrounder&#39;</span>

<span class="c1"># And if your using it for caching, sessions, etc.</span>
<span class="n">gem</span> <span class="s1">&#39;redis-rails&#39;</span></code></pre></div>

<p>Performance wise, I have have noticed a significant increase in processing speed. Resque and delayed_job were produced when Ruby/Rails was
hitting a massive explosion of growth something was needed and needed fast. Don’t get me wrong Resque is an amazing ruby gem, but if your
application is using thread-safe libraries Sidekiq will kick quite a punch when it comes to your background processes.
Upon benchmarking, Sidekiq tends to significantly outperform Resque when it comes to completing background processes.</p>

<h3 id="goworker">GoWorker</h3>
<p>Seeing as how lately I’ve been dealing with <a href="http://golang.org/">Go</a> not only for it smooth edge, but compiled libraries tent to perform significantly faster than interpreted languages, another option I considered (and still am looking into is) <a href="http://www.goworker.org/">goworker</a>.
Goworker is pretty much a drop in replacement for Resque and Sidekiq, relies on Redis as well and massively out performed them both.
But before I attempt to push this any faster and milk every drop of performance out of the application, I plan to learn quite a bit more about programming with Go.</p>

<h3 id="performance">Performance</h3>
<p>Performance wise, I have have noticed a significant increase in processing speed. Resque and delayed_job were produced when Ruby/Rails was
hitting a massive explosion of growth something was needed and needed fast. Don’t get me wrong Resque is an amazing ruby gem, but if your
application is using thread-safe libraries Sidekiq will kick quite a punch when it comes to your background processes.
Upon benchmarking, Sidekiq tends to significantly outperform Resque when it comes to completing background processes.</p>

<h3 id="goworker-1">GoWorker</h3>
<p>Seeing as how lately I’ve been dealing with <a href="http://golang.org/">Go</a> not only for it smooth edge, but compiled libraries tent to perform significantly faster than interpreted languages, another option I considered (and still am looking into is) <a href="http://www.goworker.org/">goworker</a>.
Goworker is pretty much a drop in replacement for Resque and Sidekiq, relies on Redis as well and massively out performed them both.
But before I attempt to push this any faster and milk every drop of performance out of the application, I plan to learn quite a bit more about programming with Go.</p>

</div>
        </div>
      </div>
      <!--
      <div class="footer row">
      </div>-->
    </div>
  </div>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-41384218-1', 'theworkaround.com');
  ga('send', 'pageview');
</script>
</body>
</html>